"""
We encode musical notes of variable instruments by the numerical weights of the arabic words of the Holy Quran
 without disturbing the original sequence of the 78,000 words.

Credits: This script is generated by DeepSeek
"""

import csv
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import sys
from enum import Enum


class ScaleType(Enum):
    """Musical scales to choose from."""
    CHROMATIC = "chromatic"
    MAJOR = "major"
    MINOR = "minor"
    PENTATONIC = "pentatonic"
    HIJAZ = "hijaz"  # Arabic scale
    RAGA = "raga"  # Indian classical


class InstrumentType(Enum):
    """Different instrument sounds."""
    SINE = "sine"
    SAWTOOTH = "sawtooth"
    SQUARE = "square"
    TRIANGLE = "triangle"
    FLUTE = "flute"
    PIANO = "piano"
    STRINGS = "strings"
    ORGAN = "organ"


class ArabicMusicEncoder:
    def __init__(self,
                 scale_type=ScaleType.HIJAZ,
                 instrument=InstrumentType.SINE,
                 base_freq=220.0,  # A3
                 duration_per_note=0.5):
        """
        Initialize the Arabic word weight music encoder.

        Args:
            scale_type: Musical scale to use
            instrument: Type of instrument sound
            base_freq: Base frequency for the lowest note
            duration_per_note: Duration of each note in seconds
        """

        self.scale_type = scale_type
        self.instrument = instrument
        self.base_freq = base_freq
        self.duration_per_note = duration_per_note

        # Audio parameters
        self.sample_rate = 44100  # CD quality
        self.fade_duration = 0.05

        # Define scales (ratios relative to base frequency)
        self.scales = {
            ScaleType.CHROMATIC: [1, 1.0595, 1.1225, 1.1892, 1.2599, 1.3348,
                                  1.4142, 1.4983, 1.5874, 1.6818, 1.7818, 1.8877, 2],
            ScaleType.MAJOR: [1, 1.125, 1.25, 1.3333, 1.5, 1.6667, 1.875, 2],
            ScaleType.MINOR: [1, 1.125, 1.2, 1.3333, 1.5, 1.6, 1.8, 2],
            ScaleType.PENTATONIC: [1, 1.125, 1.3333, 1.5, 1.7778, 2],
            ScaleType.HIJAZ: [1, 1.0667, 1.3333, 1.4, 1.5, 1.8, 1.8667, 2],  # Arabic Hijaz scale
            ScaleType.RAGA: [1, 1.1111, 1.25, 1.3333, 1.5, 1.6667, 1.8, 2]  # Raga Yaman
        }

        # Initialize the frequency mapping based on weights
        self.frequency_mapping = {}

    def read_csv_weights(self, csv_file, max_entries=None):
        """
        Read arabic-word-weight values from CSV file.

        Args:
            csv_file: Path to CSV file
            max_entries: Maximum number of entries to read (None for all)

        Returns:
            List of weight values
        """
        weights = []

        print(f"Reading CSV file: {csv_file}")

        try:
            with open(csv_file, 'r', newline='') as file:
                reader = csv.DictReader(file)

                total_rows = 0
                valid_rows = 0

                for row in reader:
                    total_rows += 1

                    # Stop if we've reached max_entries
                    if max_entries is not None and valid_rows >= max_entries:
                        break

                    try:
                        weight = int(row['arabic-word-weight'])

                        # Accept all positive weights (adjust range as needed)
                        if weight > 0:
                            weights.append(weight)
                            valid_rows += 1

                    except (ValueError, KeyError) as e:
                        # Skip rows with invalid data
                        continue

                print(f"Total rows in file: {total_rows:,}")
                print(f"Valid weights found: {valid_rows:,}")

                if max_entries is not None:
                    print(f"Limited to first {max_entries:,} entries")

                return weights

        except FileNotFoundError:
            print(f"Error: File '{csv_file}' not found.")
            sys.exit(1)
        except Exception as e:
            print(f"Error reading CSV file: {e}")
            sys.exit(1)

    def create_frequency_mapping(self, weights):
        """
        Create mapping from weight values to musical frequencies.

        Args:
            weights: List of weight values

        Returns:
            Dictionary mapping weight to frequency
        """
        if not weights:
            return {}

        # Get unique weights and sort them
        unique_weights = sorted(set(weights))

        # Choose scale based on scale_type
        scale = self.scales[self.scale_type]

        # Map each unique weight to a frequency in the scale
        frequency_mapping = {}

        # Calculate frequency for each weight
        for i, weight in enumerate(unique_weights):
            # Cycle through scale notes
            scale_index = i % len(scale)

            # Determine octave (how many times we've gone through the scale)
            octave = i // len(scale)

            # Calculate frequency
            frequency = self.base_freq * scale[scale_index] * (2 ** octave)

            # Limit frequency to audible range (20 Hz - 20000 Hz)
            while frequency > 20000 and octave > 0:
                octave -= 1
                frequency = frequency / 2

            frequency_mapping[weight] = frequency

        # Store mapping
        self.frequency_mapping = frequency_mapping

        print(f"\nFrequency Mapping Summary:")
        print(f"Scale type: {self.scale_type.value}")
        print(f"Number of unique weights: {len(unique_weights):,}")
        print(f"Frequency range: {min(frequency_mapping.values()):.1f} Hz to {max(frequency_mapping.values()):.1f} Hz")

        return frequency_mapping

    def generate_waveform(self, frequency, duration, amplitude=0.5):
        """
        Generate waveform based on selected instrument type.

        Args:
            frequency: Frequency in Hz
            duration: Duration in seconds
            amplitude: Amplitude (0 to 1)

        Returns:
            Audio waveform as numpy array
        """
        t = np.linspace(0, duration, int(self.sample_rate * duration), False)

        if self.instrument == InstrumentType.SINE:
            wave = amplitude * np.sin(2 * np.pi * frequency * t)

        elif self.instrument == InstrumentType.SAWTOOTH:
            # Sawtooth wave approximation with harmonics
            wave = np.zeros_like(t)
            for n in range(1, 10):  # First 10 harmonics
                wave += (amplitude / n) * np.sin(2 * np.pi * n * frequency * t)

        elif self.instrument == InstrumentType.SQUARE:
            # Square wave approximation with odd harmonics
            wave = np.zeros_like(t)
            for n in range(1, 20, 2):  # Odd harmonics up to 19th
                wave += (amplitude / n) * np.sin(2 * np.pi * n * frequency * t)

        elif self.instrument == InstrumentType.TRIANGLE:
            # Triangle wave approximation with odd harmonics
            wave = np.zeros_like(t)
            for n in range(1, 20, 2):  # Odd harmonics
                wave += (amplitude / (n ** 2)) * ((-1) ** ((n - 1) / 2)) * np.sin(2 * np.pi * n * frequency * t)

        elif self.instrument == InstrumentType.FLUTE:
            # Flute-like with strong 2nd harmonic
            wave = amplitude * np.sin(2 * np.pi * frequency * t)
            wave += 0.3 * amplitude * np.sin(2 * np.pi * 2 * frequency * t)
            wave += 0.1 * amplitude * np.sin(2 * np.pi * 3 * frequency * t)

        elif self.instrument == InstrumentType.PIANO:
            # Piano-like with multiple harmonics and fast decay
            wave = np.zeros_like(t)
            harmonics = [1.0, 0.5, 0.3, 0.2, 0.1, 0.05]
            for i, harmonic_strength in enumerate(harmonics):
                wave += harmonic_strength * amplitude * np.sin(2 * np.pi * (i + 1) * frequency * t)

        elif self.instrument == InstrumentType.STRINGS:
            # String-like with rich harmonics
            wave = np.zeros_like(t)
            for n in range(1, 15):
                wave += (amplitude / np.sqrt(n)) * np.sin(2 * np.pi * n * frequency * t)

        elif self.instrument == InstrumentType.ORGAN:
            # Organ-like with multiple harmonics
            wave = np.zeros_like(t)
            harmonics = [1.0, 0.5, 0.33, 0.25]  # 1st, 2nd, 3rd, 4th harmonics
            for i, harmonic_strength in enumerate(harmonics):
                wave += harmonic_strength * amplitude * np.sin(2 * np.pi * (i + 1) * frequency * t)

        else:
            # Default to sine wave
            wave = amplitude * np.sin(2 * np.pi * frequency * t)

        # Apply envelope
        envelope = self.create_envelope(len(wave), duration)
        wave = wave * envelope

        return wave

    def create_envelope(self, num_samples, duration):
        """
        Create ADSR envelope for natural sound.

        Args:
            num_samples: Number of samples
            duration: Duration in seconds

        Returns:
            Envelope array
        """
        # ADSR times (as fraction of duration)
        attack_time = 0.05 * duration
        decay_time = 0.1 * duration
        release_time = 0.1 * duration

        # Convert to samples
        attack_samples = int(attack_time * self.sample_rate)
        decay_samples = int(decay_time * self.sample_rate)
        release_samples = int(release_time * self.sample_rate)

        sustain_samples = num_samples - attack_samples - decay_samples - release_samples

        # Ensure positive sustain samples
        if sustain_samples < 0:
            # Adjust times proportionally
            total = num_samples
            attack_samples = int(total * 0.05)
            decay_samples = int(total * 0.1)
            release_samples = int(total * 0.1)
            sustain_samples = total - attack_samples - decay_samples - release_samples

        # Create envelope
        envelope = np.zeros(num_samples)

        # Attack
        if attack_samples > 0:
            envelope[:attack_samples] = np.linspace(0, 1, attack_samples)

        # Decay
        if decay_samples > 0:
            decay_start = attack_samples
            decay_end = decay_start + decay_samples
            envelope[decay_start:decay_end] = np.linspace(1, 0.7, decay_samples)

        # Sustain
        if sustain_samples > 0:
            sustain_start = attack_samples + decay_samples
            envelope[sustain_start:sustain_start + sustain_samples] = 0.7

        # Release
        if release_samples > 0:
            release_start = num_samples - release_samples
            envelope[release_start:] = np.linspace(envelope[release_start - 1], 0, release_samples)

        return envelope

    def encode_to_music(self, weights, output_wav="arabic_word_music.wav"):
        """
        Convert weights to musical notes and save as WAV file.

        Args:
            weights: List of weight values
            output_wav: Output WAV filename

        Returns:
            Audio waveform
        """
        if not weights:
            print("Error: No valid weights found to encode.")
            return None

        print(f"\nEncoding {len(weights):,} word weights to music...")
        print(f"Instrument: {self.instrument.value}")
        print(f"Scale: {self.scale_type.value}")
        print(f"Note duration: {self.duration_per_note}s")

        # Create frequency mapping
        self.create_frequency_mapping(weights)

        # Generate audio for each weight
        all_audio = []
        weight_stats = {}

        for i, weight in enumerate(weights):
            # Get frequency for this weight
            frequency = self.frequency_mapping.get(weight, self.base_freq)

            # Update statistics
            if weight not in weight_stats:
                weight_stats[weight] = {
                    'count': 0,
                    'frequency': frequency
                }
            weight_stats[weight]['count'] += 1

            # Generate note
            note_audio = self.generate_waveform(frequency, self.duration_per_note)
            all_audio.append(note_audio)

            # Progress indicator
            if (i + 1) % 5000 == 0:
                print(f"  Processed {i + 1:,} weights...")

        # Concatenate all notes
        audio = np.concatenate(all_audio)

        # Normalize to prevent clipping
        audio = audio / np.max(np.abs(audio)) * 0.8

        # Convert to 16-bit PCM
        audio_int16 = np.int16(audio * 32767)

        # Save as WAV file
        wavfile.write(output_wav, self.sample_rate, audio_int16)

        # Print statistics
        self.print_statistics(weight_stats, len(weights))

        print(f"\nMusic encoded successfully!")
        print(f"Output saved as: {output_wav}")
        print(f"Total duration: {len(audio) / self.sample_rate:.2f} seconds")
        print(f"File size: {len(audio_int16) * 2 / (1024 * 1024):.2f} MB")

        return audio

    def print_statistics(self, weight_stats, total_notes):
        """
        Print statistics about weight distribution.

        Args:
            weight_stats: Dictionary with weight statistics
            total_notes: Total number of notes
        """
        print("\n" + "=" * 70)
        print("WEIGHT DISTRIBUTION STATISTICS:")
        print("=" * 70)
        print(f"{'Weight':<10} {'Frequency (Hz)':<15} {'Count':<10} {'Percentage':<10}")
        print("-" * 70)

        # Sort weights for display
        sorted_weights = sorted(weight_stats.items(), key=lambda x: x[0])

        for weight, stats in sorted_weights[:20]:  # Show first 20
            count = stats['count']
            frequency = stats['frequency']
            percentage = (count / total_notes * 100)

            print(f"{weight:<10} {frequency:<15.1f} {count:<10,} {percentage:<10.2f}%")

        if len(sorted_weights) > 20:
            print(f"... and {len(sorted_weights) - 20} more unique weights")

        # Summary statistics
        all_weights = list(weight_stats.keys())
        print("\nSummary:")
        print(f"  Minimum weight: {min(all_weights)}")
        print(f"  Maximum weight: {max(all_weights)}")
        print(f"  Average weight: {sum(all_weights) / len(all_weights):.1f}")
        print(f"  Unique weights: {len(all_weights):,}")

        print("=" * 70)


def interactive_configuration():
    """
    Interactive configuration for the encoder.

    Returns:
        Configuration dictionary
    """
    print("\n" + "=" * 60)
    print("ARABIC WORD WEIGHT MUSIC ENCODER - CONFIGURATION")
    print("=" * 60)

    # Choose scale
    print("\nAvailable Musical Scales:")
    for i, scale in enumerate(ScaleType):
        print(f"  {i + 1}. {scale.value.capitalize()}")

    scale_choice = input(f"\nChoose scale (1-{len(ScaleType)}): ").strip()
    try:
        scale_index = int(scale_choice) - 1
        if 0 <= scale_index < len(ScaleType):
            scale_type = list(ScaleType)[scale_index]
        else:
            print("Invalid choice. Using Hijaz scale.")
            scale_type = ScaleType.HIJAZ
    except:
        print("Invalid input. Using Hijaz scale.")
        scale_type = ScaleType.HIJAZ

    # Choose instrument
    print("\nAvailable Instruments:")
    for i, instrument in enumerate(InstrumentType):
        print(f"  {i + 1}. {instrument.value.capitalize()}")

    instrument_choice = input(f"\nChoose instrument (1-{len(InstrumentType)}): ").strip()
    try:
        instrument_index = int(instrument_choice) - 1
        if 0 <= instrument_index < len(InstrumentType):
            instrument = list(InstrumentType)[instrument_index]
        else:
            print("Invalid choice. Using sine wave.")
            instrument = InstrumentType.SINE
    except:
        print("Invalid input. Using sine wave.")
        instrument = InstrumentType.SINE

    # Choose note duration
    print("\nNote Duration Options:")
    print("  1. Short notes (0.2 seconds)")
    print("  2. Medium notes (0.5 seconds) - Recommended")
    print("  3. Long notes (1.0 seconds)")

    duration_choice = input("\nChoose duration (1-3): ").strip()
    if duration_choice == "1":
        duration = 0.2
    elif duration_choice == "3":
        duration = 1.0
    else:
        duration = 0.5

    # Choose number of entries
    print("\nNumber of entries to process:")
    print("  1. All entries (78,131)")
    print("  2. First 10,000 entries")
    print("  3. First 1,000 entries (for testing)")
    print("  4. Custom number")

    entries_choice = input("\nChoose option (1-4): ").strip()
    if entries_choice == "1":
        max_entries = None
    elif entries_choice == "2":
        max_entries = 10000
    elif entries_choice == "3":
        max_entries = 1000
    elif entries_choice == "4":
        try:
            max_entries = int(input("Enter custom number: "))
        except:
            print("Invalid input. Using 10,000 entries.")
            max_entries = 10000
    else:
        max_entries = 10000

    # Base frequency
    try:
        base_freq = float(input("\nBase frequency in Hz (default 220.0): ") or "220.0")
    except:
        base_freq = 220.0

    return {
        'scale_type': scale_type,
        'instrument': instrument,
        'duration': duration,
        'max_entries': max_entries,
        'base_freq': base_freq
    }


def main():
    """Main function to run the Arabic word weight music encoder."""

    # File configuration
    CSV_FILE = "dictQM_WW_03_Dec_2025.csv"

    print("=" * 60)
    print("ARABIC WORD WEIGHT MUSIC ENCODER")
    print("=" * 60)

    # Get interactive configuration
    config = interactive_configuration()

    # Create output filename based on configuration
    output_wav = f"arabic_word_{config['scale_type'].value}_{config['instrument'].value}.wav"

    # Initialize encoder with configuration
    encoder = ArabicMusicEncoder(
        scale_type=config['scale_type'],
        instrument=config['instrument'],
        base_freq=config['base_freq'],
        duration_per_note=config['duration']
    )

    # Read weights from CSV
    weights = encoder.read_csv_weights(CSV_FILE, config['max_entries'])

    if not weights:
        print("No valid weights found. Exiting.")
        return

    # Encode to music
    audio = encoder.encode_to_music(weights, output_wav)

    # Create simple waveform plot
    if audio is not None:
        try:
            plt.figure(figsize=(12, 4))
            plt.plot(audio[:min(44100, len(audio))])  # First second
            plt.title(
                f"Waveform Preview - {config['scale_type'].value.capitalize()} Scale, {config['instrument'].value.capitalize()}")
            plt.xlabel("Samples")
            plt.ylabel("Amplitude")
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            plt.savefig("waveform_preview.png", dpi=150)
            print(f"\nWaveform preview saved as: waveform_preview.png")
            plt.close()
        except Exception as e:
            print(f"\nCould not create preview plot: {e}")

    print("\n" + "=" * 60)
    print("ENCODING COMPLETE!")
    print(f"Output file: {output_wav}")
    print("=" * 60)


if __name__ == "__main__":
    main()