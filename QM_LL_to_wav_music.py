"""
We encode musical notes of flute instrument by the numerical weights of the arabic letters without disturbing the
original sequence of the 330,000 letters.

Credits: This script is generated by DeepSeek
"""


import csv
import librosa
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import sys


class FluteMusicEncoder:
    def __init__(self):
        """Initialize the flute music encoder with C major scale mapping."""

        # C Major scale notes (flute range approximately C4 to C6)
        # Mapping digits 1-9 to notes in C Major
        self.note_mapping = {
            1: 261.63,  # C4 (Middle C)
            2: 293.66,  # D4
            3: 329.63,  # E4
            4: 349.23,  # F4
            5: 392.00,  # G4
            6: 440.00,  # A4
            7: 493.88,  # B4
            8: 523.25,  # C5
            9: 587.33  # D5 (extended)
        }

        # Note names for display
        self.note_names = {
            1: "C4", 2: "D4", 3: "E4", 4: "F4",
            5: "G4", 6: "A4", 7: "B4", 8: "C5", 9: "D5"
        }

        # Audio parameters
        self.sample_rate = 44100  # CD quality
        self.duration_per_note = 0.3  # seconds per note
        self.fade_duration = 0.05  # fade in/out to avoid clicks

    def read_csv_weights(self, csv_file):
        """Read arabic-letter-weight values from CSV file."""
        weights = []

        print(f"Reading CSV file: {csv_file}")

        try:
            with open(csv_file, 'r', newline='') as file:
                reader = csv.DictReader(file)

                # Count total rows and valid weights
                total_rows = 0
                valid_rows = 0

                for row in reader:
                    total_rows += 1
                    try:
                        weight = int(row['arabic-letter-weight'])

                        # Only keep weights between 1 and 9
                        if 1 <= weight <= 9:
                            weights.append(weight)
                            valid_rows += 1
                        else:
                            # Optionally, you can handle out-of-range values differently
                            # For now, we skip them
                            pass

                    except (ValueError, KeyError) as e:
                        # Skip rows with invalid data
                        continue

                print(f"Total rows processed: {total_rows:,}")
                print(f"Valid weights (1-9) found: {valid_rows:,}")
                print(f"Invalid/skipped rows: {total_rows - valid_rows:,}")

                return weights

        except FileNotFoundError:
            print(f"Error: File '{csv_file}' not found.")
            sys.exit(1)
        except Exception as e:
            print(f"Error reading CSV file: {e}")
            sys.exit(1)

    def generate_flute_wave(self, frequency, duration, amplitude=0.5):
        """Generate a flute-like sine wave with harmonics."""

        # Flute has a rich harmonic structure
        t = np.linspace(0, duration, int(self.sample_rate * duration), False)

        # Base frequency (fundamental)
        wave = amplitude * np.sin(2 * np.pi * frequency * t)

        # Add harmonics for flute-like sound (flute has strong 2nd harmonic)
        wave += 0.3 * amplitude * np.sin(2 * np.pi * 2 * frequency * t)  # 2nd harmonic
        wave += 0.1 * amplitude * np.sin(2 * np.pi * 3 * frequency * t)  # 3rd harmonic

        # Apply attack-decay-sustain-release (ADSR) envelope
        envelope = self.create_adsr_envelope(len(wave), duration)
        wave = wave * envelope

        return wave

    def create_adsr_envelope(self, num_samples, duration):
        """Create ADSR envelope for natural flute sound."""

        # ADSR parameters (in seconds)
        attack_time = 0.02
        decay_time = 0.05
        sustain_level = 0.7
        release_time = 0.03

        # Convert times to samples
        attack_samples = int(attack_time * self.sample_rate)
        decay_samples = int(decay_time * self.sample_rate)
        release_samples = int(release_time * self.sample_rate)
        sustain_samples = num_samples - attack_samples - decay_samples - release_samples

        # Ensure we have enough samples
        if sustain_samples < 0:
            # Adjust times if note is too short
            attack_samples = int(num_samples * 0.1)
            decay_samples = int(num_samples * 0.2)
            release_samples = int(num_samples * 0.1)
            sustain_samples = num_samples - attack_samples - decay_samples - release_samples

        # Create envelope
        envelope = np.zeros(num_samples)

        # Attack (linear rise)
        envelope[:attack_samples] = np.linspace(0, 1, attack_samples)

        # Decay (exponential decay to sustain level)
        if decay_samples > 0:
            decay_start = attack_samples
            decay_end = decay_start + decay_samples
            decay_env = np.exp(np.linspace(0, -2, decay_samples))  # Exponential decay
            decay_env = decay_env * (1 - sustain_level) + sustain_level
            envelope[decay_start:decay_end] = decay_env

        # Sustain
        if sustain_samples > 0:
            sustain_start = attack_samples + decay_samples
            envelope[sustain_start:sustain_start + sustain_samples] = sustain_level

        # Release (exponential decay to 0)
        if release_samples > 0:
            release_start = num_samples - release_samples
            release_env = np.exp(np.linspace(0, -5, release_samples))
            release_env = release_env * envelope[release_start - 1]  # Start from sustain level
            envelope[release_start:] = release_env

        return envelope

    def encode_to_music(self, weights, output_wav="output.wav"):
        """Convert weights to musical notes and save as WAV file."""

        if not weights:
            print("Error: No valid weights found to encode.")
            return


        print(f"\nEncoding {len(weights):,} notes to music...")

        # Generate audio for each note
        all_audio = []

        # Statistics
        note_counts = {digit: 0 for digit in range(1, 10)}

        for i, weight in enumerate(weights):
            # Get frequency for this weight
            frequency = self.note_mapping[weight]

            # Update statistics
            note_counts[weight] += 1

            # Generate note
            note_audio = self.generate_flute_wave(frequency, self.duration_per_note)
            all_audio.append(note_audio)

            # Progress indicator
            if (i + 1) % 10000 == 0:
                print(f"  Processed {i + 1:,} notes...")

        # Concatenate all notes
        audio = np.concatenate(all_audio)

        # Normalize to prevent clipping
        audio = audio / np.max(np.abs(audio)) * 0.8

        # Convert to 16-bit PCM
        audio_int16 = np.int16(audio * 32767)

        # Save as WAV file
        wavfile.write(output_wav, self.sample_rate, audio_int16)

        print(f"\nMusic encoded successfully!")
        print(f"Output saved as: {output_wav}")
        print(f"Total duration: {len(audio) / self.sample_rate:.2f} seconds")
        print(f"  ({len(weights)} notes Ã— {self.duration_per_note}s = {len(weights) * self.duration_per_note:.2f}s)")

        # Print statistics
        self.print_statistics(note_counts, len(weights))

        return audio

    def print_statistics(self, note_counts, total_notes):
        """Print statistics about note distribution."""

        print("\n" + "=" * 50)
        print("NOTE DISTRIBUTION STATISTICS:")
        print("=" * 50)
        print(f"{'Digit':<6} {'Note':<6} {'Frequency (Hz)':<15} {'Count':<10} {'Percentage':<10}")
        print("-" * 50)

        for digit in range(1, 10):
            count = note_counts[digit]
            percentage = (count / total_notes * 100) if total_notes > 0 else 0
            note_name = self.note_names[digit]
            frequency = self.note_mapping[digit]

            print(f"{digit:<6} {note_name:<6} {frequency:<15.2f} {count:<10,} {percentage:<10.2f}%")

        print("=" * 50)

    def create_preview(self, audio, weights, preview_length=10):
        """Create a preview plot of the music."""

        # Create a short preview (first N seconds)
        preview_samples = min(preview_length * self.sample_rate, len(audio))
        preview_audio = audio[:preview_samples]

        # Create time axis
        time = np.linspace(0, preview_samples / self.sample_rate, preview_samples)

        # Plot the audio waveform
        plt.figure(figsize=(15, 8))

        plt.subplot(2, 1, 1)
        plt.plot(time, preview_audio)
        plt.title(f'Flute Music Preview (First {preview_length} seconds)')
        plt.xlabel('Time (s)')
        plt.ylabel('Amplitude')
        plt.grid(True, alpha=0.3)

        # Plot spectrogram
        plt.subplot(2, 1, 2)
        n_fft = 2048
        hop_length = 512
        D = librosa.amplitude_to_db(np.abs(librosa.stft(preview_audio,
                                                        n_fft=n_fft,
                                                        hop_length=hop_length)),
                                    ref=np.max)
        librosa.display.specshow(D, sr=self.sample_rate,
                                 hop_length=hop_length,
                                 x_axis='time',
                                 y_axis='log')
        plt.colorbar(format='%+2.0f dB')
        plt.title('Spectrogram')
        plt.tight_layout()

        # Save preview plot
        plt.savefig('music_preview.png', dpi=150, bbox_inches='tight')
        print(f"\nPreview plot saved as: music_preview.png")

        # Show first few notes as text
        print("\nFirst 20 notes in sequence:")
        print("Index | Digit | Note | Frequency")
        print("-" * 35)
        for i in range(min(20, len(weights))):
            weight = weights[i]
            note_name = self.note_names[weight]
            frequency = self.note_mapping[weight]
            print(f"{i + 1:5} | {weight:5} | {note_name:4} | {frequency:8.2f} Hz")


def main():
    """Main function to run the flute music encoder."""

    # Configuration
    CSV_FILE = "dictQM_LL_single_digit_06_Dec_2025.csv"
    OUTPUT_WAV = "flute_encoded_output.wav"
    MAX_ENTRIES = 10000  # Number of entries to process

    print("=" * 60)
    print("FLUTE MUSIC ENCODER")
    print("=" * 60)
    print("Encoding arabic-letter-weight values (1-9) to C Major flute music")
    print("=" * 60)

    # Initialize encoder
    encoder = FluteMusicEncoder()

    # Read weights from CSV
    weights = encoder.read_csv_weights(CSV_FILE)
    weights = weights[:MAX_ENTRIES]

    if not weights:
        print("No valid weights found. Exiting.")
        return

    # Encode to music
    audio = encoder.encode_to_music(weights, OUTPUT_WAV)

    # Create preview (optional - requires librosa)
    try:
        import librosa
        import librosa.display

        print("\nCreating preview visualization...")
        encoder.create_preview(audio, weights)
    except ImportError:
        print("\nNote: Install librosa for visualization: pip install librosa")

    # Play a short preview (optional)
    try:
        import sounddevice as sd

        print("\nPlaying 5-second preview...")
        preview_length = min(5 * encoder.sample_rate, len(audio))
        sd.play(audio[:preview_length], encoder.sample_rate)
        sd.wait()
    except ImportError:
        print("\nNote: Install sounddevice for audio playback: pip install sounddevice")

    print("\n" + "=" * 60)
    print("ENCODING COMPLETE!")
    print(f"Check '{OUTPUT_WAV}' for your flute music")
    print("=" * 60)


if __name__ == "__main__":
    main()