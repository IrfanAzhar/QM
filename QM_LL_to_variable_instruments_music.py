"""
We encode musical notes of variable instruments by the numerical weights of the arabic letters without disturbing the
original sequence of the 330,000 letters.

Credits: This script is generated by DeepSeek
"""

import csv
import numpy as np
from scipy.io import wavfile
import matplotlib.pyplot as plt
import sys
from enum import Enum
import json
from dataclasses import dataclass
from typing import Optional, Dict, List, Tuple


# ============================================================================
# ENUMS AND DATA CLASSES FOR FLEXIBLE CONFIGURATION
# ============================================================================

class InstrumentType(Enum):
    """Available instrument types."""
    SINE = "sine"
    FLUTE = "flute"
    PIANO = "piano"
    VIOLIN = "violin"
    CELLO = "cello"
    TRUMPET = "trumpet"
    SAXOPHONE = "saxophone"
    GUITAR = "guitar"
    HARP = "harp"
    MARIMBA = "marimba"
    SAWTOOTH = "sawtooth"
    SQUARE = "square"
    TRIANGLE = "triangle"


class ScaleType(Enum):
    """Available musical scales."""
    C_MAJOR = "c_major"
    C_MINOR = "c_minor"
    PENTATONIC = "pentatonic"
    CHROMATIC = "chromatic"
    HIJAZ = "hijaz"  # Arabic scale
    PHYRIGIAN = "phyrigian"
    DORIAN = "dorian"
    BLUES = "blues"
    WHOLE_TONE = "whole_tone"


class OutputFormat(Enum):
    """Available output formats."""
    WAV = "wav"
    MP3 = "mp3"
    OGG = "ogg"


@dataclass
class MusicConfig:
    """Configuration for music generation."""
    # Instrument settings
    instrument: InstrumentType = InstrumentType.FLUTE
    volume: float = 0.7  # 0.0 to 1.0

    # Note settings
    scale: ScaleType = ScaleType.C_MAJOR
    base_octave: int = 4  # Middle octave
    note_duration: float = 0.3  # seconds
    rest_duration: float = 0.0  # seconds between notes
    portamento: bool = False  # smooth transitions between notes
    vibrato_depth: float = 0.0  # 0.0 to 1.0
    vibrato_rate: float = 5.0  # Hz

    # ADSR envelope settings
    attack_time: float = 0.02  # seconds
    decay_time: float = 0.05  # seconds
    sustain_level: float = 0.7  # 0.0 to 1.0
    release_time: float = 0.03  # seconds

    # Reverb settings
    reverb_level: float = 0.0  # 0.0 to 1.0
    reverb_delay: float = 0.1  # seconds

    # Output settings
    sample_rate: int = 44100
    bit_depth: int = 16
    normalize: bool = True
    output_format: OutputFormat = OutputFormat.WAV

    # Processing settings
    max_entries: Optional[int] = None
    shuffle_notes: bool = False
    repeat_pattern: int = 1  # number of times to repeat sequence


# ============================================================================
# MUSIC ENCODER CLASS
# ============================================================================

class FlexibleMusicEncoder:
    def __init__(self, config: Optional[MusicConfig] = None):
        """
        Initialize the music encoder with flexible configuration.

        Args:
            config: MusicConfig object with all settings
        """
        self.config = config or MusicConfig()

        # Define scales (ratios to base frequency)
        self.scales = {
            ScaleType.C_MAJOR: [1, 9 / 8, 5 / 4, 4 / 3, 3 / 2, 5 / 3, 15 / 8, 2],
            ScaleType.C_MINOR: [1, 9 / 8, 6 / 5, 4 / 3, 3 / 2, 8 / 5, 9 / 5, 2],
            ScaleType.PENTATONIC: [1, 9 / 8, 5 / 4, 3 / 2, 5 / 3, 2],
            ScaleType.CHROMATIC: [1, 16 / 15, 9 / 8, 6 / 5, 5 / 4, 4 / 3, 7 / 5, 3 / 2,
                                  8 / 5, 5 / 3, 7 / 4, 15 / 8, 2],
            ScaleType.HIJAZ: [1, 16 / 15, 4 / 3, 7 / 5, 3 / 2, 8 / 5, 9 / 5, 2],
            ScaleType.PHYRIGIAN: [1, 16 / 15, 6 / 5, 4 / 3, 3 / 2, 8 / 5, 9 / 5, 2],
            ScaleType.DORIAN: [1, 9 / 8, 6 / 5, 4 / 3, 3 / 2, 5 / 3, 9 / 5, 2],
            ScaleType.BLUES: [1, 8 / 7, 6 / 5, 4 / 3, 7 / 5, 3 / 2, 12 / 7, 2],
            ScaleType.WHOLE_TONE: [1, 9 / 8, 5 / 4, 7 / 5, 3 / 2, 12 / 7, 2]
        }

        # Base frequencies for each octave (C notes)
        self.base_frequencies = {
            0: 16.35,  # C0
            1: 32.70,  # C1
            2: 65.41,  # C2
            3: 130.81,  # C3
            4: 261.63,  # C4 (Middle C)
            5: 523.25,  # C5
            6: 1046.50,  # C6
            7: 2093.00,  # C7
            8: 4186.01  # C8
        }

        # Note names for display
        self.note_names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]

        # Initialize note mapping
        self.note_mapping = {}
        self.generate_note_mapping()

    def generate_note_mapping(self):
        """Generate mapping from digits 1-9 to musical frequencies based on scale."""
        base_freq = self.base_frequencies[self.config.base_octave]
        scale = self.scales[self.config.scale]

        # Map digits 1-9 to scale notes (cycling through scale if needed)
        for digit in range(1, 10):
            scale_index = (digit - 1) % len(scale)
            octave_offset = (digit - 1) // len(scale)
            frequency = base_freq * scale[scale_index] * (2 ** octave_offset)
            self.note_mapping[digit] = frequency

    def read_csv_weights(self, csv_file: str) -> List[int]:
        """
        Read arabic-letter-weight values from CSV file.

        Args:
            csv_file: Path to CSV file

        Returns:
            List of weight values (1-9)
        """
        weights = []

        print(f"üìÅ Reading CSV file: {csv_file}")

        try:
            with open(csv_file, 'r', newline='', encoding='utf-8') as file:
                reader = csv.DictReader(file)

                total_rows = 0
                valid_rows = 0

                for row in reader:
                    total_rows += 1

                    # Stop if we've reached max_entries
                    if self.config.max_entries and valid_rows >= self.config.max_entries:
                        break

                    try:
                        weight = int(row['arabic-letter-weight'])

                        # Only keep weights between 1 and 9
                        if 1 <= weight <= 9:
                            weights.append(weight)
                            valid_rows += 1
                        else:
                            # Skip out-of-range values
                            continue

                    except (ValueError, KeyError) as e:
                        continue

                print(f"   Total rows: {total_rows:,}")
                print(f"   Valid weights (1-9): {valid_rows:,}")

                if self.config.max_entries:
                    print(f"   Limited to first {self.config.max_entries:,} entries")
                    weights = weights[:self.config.max_entries]

                return weights

        except FileNotFoundError:
            print(f"‚ùå Error: File '{csv_file}' not found.")
            sys.exit(1)
        except Exception as e:
            print(f"‚ùå Error reading CSV file: {e}")
            sys.exit(1)

    def generate_instrument_wave(self, frequency: float, duration: float) -> np.ndarray:
        """
        Generate waveform based on selected instrument.

        Args:
            frequency: Frequency in Hz
            duration: Duration in seconds

        Returns:
            Audio waveform
        """
        t = np.linspace(0, duration, int(self.config.sample_rate * duration), False)

        if self.config.instrument == InstrumentType.SINE:
            wave = self.config.volume * np.sin(2 * np.pi * frequency * t)

        elif self.config.instrument == InstrumentType.FLUTE:
            # Flute with harmonics
            wave = self.config.volume * np.sin(2 * np.pi * frequency * t)
            wave += 0.3 * self.config.volume * np.sin(2 * np.pi * 2 * frequency * t)
            wave += 0.1 * self.config.volume * np.sin(2 * np.pi * 3 * frequency * t)

        elif self.config.instrument == InstrumentType.PIANO:
            # Piano with harmonic series and fast decay
            wave = np.zeros_like(t)
            harmonics = [1.0, 0.5, 0.25, 0.125, 0.0625]
            for i, harmonic_strength in enumerate(harmonics):
                wave += harmonic_strength * self.config.volume * np.sin(2 * np.pi * (i + 1) * frequency * t)

        elif self.config.instrument == InstrumentType.VIOLIN:
            # Violin with rich harmonics and slow attack
            wave = np.zeros_like(t)
            for n in range(1, 8):
                wave += (self.config.volume / n) * np.sin(2 * np.pi * n * frequency * t)

        elif self.config.instrument == InstrumentType.CELLO:
            # Cello with strong fundamental
            wave = self.config.volume * np.sin(2 * np.pi * frequency * t)
            wave += 0.2 * self.config.volume * np.sin(2 * np.pi * 2 * frequency * t)
            wave += 0.05 * self.config.volume * np.sin(2 * np.pi * 3 * frequency * t)

        elif self.config.instrument == InstrumentType.TRUMPET:
            # Trumpet with bright harmonics
            wave = np.zeros_like(t)
            harmonics = [1.0, 0.8, 0.6, 0.4, 0.2]
            for i, harmonic_strength in enumerate(harmonics):
                wave += harmonic_strength * self.config.volume * np.sin(2 * np.pi * (i + 1) * frequency * t)

        elif self.config.instrument == InstrumentType.SAXOPHONE:
            # Saxophone with complex harmonics
            wave = self.config.volume * np.sin(2 * np.pi * frequency * t)
            wave += 0.4 * self.config.volume * np.sin(2 * np.pi * 2 * frequency * t)
            wave += 0.2 * self.config.volume * np.sin(2 * np.pi * 3 * frequency * t)
            wave += 0.1 * self.config.volume * np.sin(2 * np.pi * 4 * frequency * t)

        elif self.config.instrument == InstrumentType.GUITAR:
            # Guitar with string-like harmonics
            wave = np.zeros_like(t)
            for n in range(1, 6):
                wave += (self.config.volume / np.sqrt(n)) * np.sin(2 * np.pi * n * frequency * t)

        elif self.config.instrument == InstrumentType.HARP:
            # Harp with clear harmonics
            wave = self.config.volume * np.sin(2 * np.pi * frequency * t)
            wave += 0.5 * self.config.volume * np.sin(2 * np.pi * 2 * frequency * t)
            wave += 0.2 * self.config.volume * np.sin(2 * np.pi * 3 * frequency * t)

        elif self.config.instrument == InstrumentType.MARIMBA:
            # Marimba with percussive envelope
            wave = self.config.volume * np.sin(2 * np.pi * frequency * t)
            wave += 0.3 * self.config.volume * np.sin(2 * np.pi * 2 * frequency * t)
            wave += 0.1 * self.config.volume * np.sin(2 * np.pi * 3 * frequency * t)

        elif self.config.instrument == InstrumentType.SAWTOOTH:
            # Sawtooth wave
            wave = np.zeros_like(t)
            for n in range(1, 20):
                wave += (self.config.volume / n) * np.sin(2 * np.pi * n * frequency * t)

        elif self.config.instrument == InstrumentType.SQUARE:
            # Square wave
            wave = np.zeros_like(t)
            for n in range(1, 40, 2):
                wave += (self.config.volume / n) * np.sin(2 * np.pi * n * frequency * t)

        elif self.config.instrument == InstrumentType.TRIANGLE:
            # Triangle wave
            wave = np.zeros_like(t)
            for n in range(1, 40, 2):
                wave += (self.config.volume / (n ** 2)) * ((-1) ** ((n - 1) / 2)) * np.sin(
                    2 * np.pi * n * frequency * t)

        else:
            # Default to sine wave
            wave = self.config.volume * np.sin(2 * np.pi * frequency * t)

        # Apply vibrato if enabled
        if self.config.vibrato_depth > 0:
            vibrato = self.config.vibrato_depth * np.sin(2 * np.pi * self.config.vibrato_rate * t)
            wave = wave * (1 + 0.1 * vibrato)

        # Apply envelope
        envelope = self.create_adsr_envelope(len(wave), duration)
        wave = wave * envelope

        return wave

    def create_adsr_envelope(self, num_samples: int, duration: float) -> np.ndarray:
        """
        Create ADSR envelope for natural sound.

        Args:
            num_samples: Number of samples
            duration: Duration in seconds

        Returns:
            Envelope array
        """
        # Convert times to samples
        attack_samples = int(self.config.attack_time * self.config.sample_rate)
        decay_samples = int(self.config.decay_time * self.config.sample_rate)
        release_samples = int(self.config.release_time * self.config.sample_rate)

        sustain_samples = num_samples - attack_samples - decay_samples - release_samples

        # Ensure we have enough samples
        if sustain_samples < 0:
            # Adjust times proportionally
            total = num_samples
            attack_samples = int(total * 0.1)
            decay_samples = int(total * 0.2)
            release_samples = int(total * 0.1)
            sustain_samples = total - attack_samples - decay_samples - release_samples

        # Create envelope
        envelope = np.zeros(num_samples)

        # Attack
        if attack_samples > 0:
            envelope[:attack_samples] = np.linspace(0, 1, attack_samples)

        # Decay
        if decay_samples > 0:
            decay_start = attack_samples
            decay_end = decay_start + decay_samples
            envelope[decay_start:decay_end] = np.linspace(1, self.config.sustain_level, decay_samples)

        # Sustain
        if sustain_samples > 0:
            sustain_start = attack_samples + decay_samples
            envelope[sustain_start:sustain_start + sustain_samples] = self.config.sustain_level

        # Release
        if release_samples > 0:
            release_start = num_samples - release_samples
            if release_start > 0:
                start_value = envelope[release_start - 1]
                envelope[release_start:] = np.linspace(start_value, 0, release_samples)

        return envelope

    def add_reverb(self, audio: np.ndarray) -> np.ndarray:
        """Add reverb effect to audio."""
        if self.config.reverb_level <= 0:
            return audio

        delay_samples = int(self.config.reverb_delay * self.config.sample_rate)
        reverb_signal = np.zeros(len(audio) + delay_samples)
        reverb_signal[:len(audio)] = audio

        # Create delayed version
        for i in range(1, 4):  # Multiple reflections
            delay = delay_samples * i
            if delay < len(reverb_signal):
                reverb_signal[delay:delay + len(audio)] += audio * (self.config.reverb_level / (i * 2))

        # Trim to original length
        reverb_signal = reverb_signal[:len(audio)]

        # Mix with original
        wet = self.config.reverb_level
        dry = 1 - wet
        result = dry * audio + wet * reverb_signal

        return result

    def encode_to_music(self, weights: List[int], output_file: str = "output.wav") -> np.ndarray:
        """
        Convert weights to musical notes and save as audio file.

        Args:
            weights: List of weight values
            output_file: Output filename

        Returns:
            Audio waveform
        """
        if not weights:
            print("‚ùå Error: No valid weights found to encode.")
            return np.array([])

        print(f"\nüéµ Encoding {len(weights):,} notes to music...")
        print(f"   Instrument: {self.config.instrument.value}")
        print(f"   Scale: {self.config.scale.value}")
        print(f"   Note duration: {self.config.note_duration}s")

        # Shuffle if requested
        if self.config.shuffle_notes:
            import random
            random.shuffle(weights)
            print("   Notes shuffled")

        # Repeat pattern if requested
        if self.config.repeat_pattern > 1:
            original_weights = weights.copy()
            weights = []
            for _ in range(self.config.repeat_pattern):
                weights.extend(original_weights)
            print(f"   Pattern repeated {self.config.repeat_pattern} times")

        # Generate audio for each note
        all_audio = []
        note_stats = {digit: 0 for digit in range(1, 10)}

        for i, weight in enumerate(weights):
            # Get frequency for this weight
            frequency = self.note_mapping[weight]

            # Update statistics
            note_stats[weight] += 1

            # Generate note
            note_audio = self.generate_instrument_wave(frequency, self.config.note_duration)
            all_audio.append(note_audio)

            # Add rest if specified
            if self.config.rest_duration > 0:
                rest_audio = np.zeros(int(self.config.sample_rate * self.config.rest_duration))
                all_audio.append(rest_audio)

            # Progress indicator
            if (i + 1) % 10000 == 0:
                print(f"   Processed {i + 1:,} notes...")

        # Concatenate all notes
        audio = np.concatenate(all_audio)

        # Add reverb if enabled
        if self.config.reverb_level > 0:
            audio = self.add_reverb(audio)

        # Normalize if requested
        if self.config.normalize:
            max_val = np.max(np.abs(audio))
            if max_val > 0:
                audio = audio / max_val * 0.8

        # Convert to appropriate bit depth
        if self.config.bit_depth == 16:
            audio_int = np.int16(audio * 32767)
        elif self.config.bit_depth == 24:
            audio_int = np.int32(audio * 8388607)
        else:  # 32-bit float
            audio_int = audio.astype(np.float32)

        # Save as WAV file
        wavfile.write(output_file, self.config.sample_rate, audio_int)

        # Print statistics
        self.print_statistics(note_stats, len(weights))

        print(f"\n‚úÖ Music encoded successfully!")
        print(f"   Output saved as: {output_file}")
        print(f"   Total duration: {len(audio) / self.config.sample_rate:.2f} seconds")

        return audio

    def print_statistics(self, note_stats: Dict[int, int], total_notes: int):
        """Print statistics about note distribution."""

        print("\n" + "=" * 60)
        print("üìä NOTE DISTRIBUTION STATISTICS:")
        print("=" * 60)
        print(f"{'Digit':<6} {'Note':<8} {'Frequency (Hz)':<15} {'Count':<10} {'Percentage':<10}")
        print("-" * 60)

        for digit in range(1, 10):
            count = note_stats[digit]
            percentage = (count / total_notes * 100) if total_notes > 0 else 0
            frequency = self.note_mapping[digit]

            # Find note name
            base_freq = self.base_frequencies[self.config.base_octave]
            ratio = frequency / base_freq

            # Simple note naming (approximate)
            if ratio < 1.06:
                note_name = "C"
            elif ratio < 1.13:
                note_name = "C#/Db"
            elif ratio < 1.2:
                note_name = "D"
            elif ratio < 1.27:
                note_name = "D#/Eb"
            elif ratio < 1.34:
                note_name = "E"
            elif ratio < 1.42:
                note_name = "F"
            elif ratio < 1.5:
                note_name = "F#/Gb"
            elif ratio < 1.6:
                note_name = "G"
            elif ratio < 1.7:
                note_name = "G#/Ab"
            elif ratio < 1.8:
                note_name = "A"
            elif ratio < 1.9:
                note_name = "A#/Bb"
            else:
                note_name = "B"

            print(f"{digit:<6} {note_name:<8} {frequency:<15.2f} {count:<10,} {percentage:<10.2f}%")

        print("=" * 60)

    def save_config(self, filename: str = "music_config.json"):
        """Save current configuration to JSON file."""
        config_dict = {
            'instrument': self.config.instrument.value,
            'volume': self.config.volume,
            'scale': self.config.scale.value,
            'base_octave': self.config.base_octave,
            'note_duration': self.config.note_duration,
            'rest_duration': self.config.rest_duration,
            'attack_time': self.config.attack_time,
            'decay_time': self.config.decay_time,
            'sustain_level': self.config.sustain_level,
            'release_time': self.config.release_time,
            'sample_rate': self.config.sample_rate,
            'max_entries': self.config.max_entries
        }

        with open(filename, 'w') as f:
            json.dump(config_dict, f, indent=2)

        print(f"üìù Configuration saved to: {filename}")

    def load_config(self, filename: str = "music_config.json"):
        """Load configuration from JSON file."""
        try:
            with open(filename, 'r') as f:
                config_dict = json.load(f)

            # Update config
            self.config.instrument = InstrumentType(config_dict.get('instrument', 'flute'))
            self.config.volume = config_dict.get('volume', 0.7)
            self.config.scale = ScaleType(config_dict.get('scale', 'c_major'))
            self.config.base_octave = config_dict.get('base_octave', 4)
            self.config.note_duration = config_dict.get('note_duration', 0.3)
            self.config.rest_duration = config_dict.get('rest_duration', 0.0)
            self.config.attack_time = config_dict.get('attack_time', 0.02)
            self.config.decay_time = config_dict.get('decay_time', 0.05)
            self.config.sustain_level = config_dict.get('sustain_level', 0.7)
            self.config.release_time = config_dict.get('release_time', 0.03)
            self.config.sample_rate = config_dict.get('sample_rate', 44100)
            self.config.max_entries = config_dict.get('max_entries', None)

            # Regenerate note mapping
            self.generate_note_mapping()

            print(f"üìù Configuration loaded from: {filename}")

        except FileNotFoundError:
            print(f"‚ö†Ô∏è  Config file not found: {filename}")
        except Exception as e:
            print(f"‚ùå Error loading config: {e}")


# ============================================================================
# INTERACTIVE CONFIGURATION AND MAIN FUNCTION
# ============================================================================

def interactive_configuration() -> MusicConfig:
    """
    Interactive configuration menu.

    Returns:
        MusicConfig object with user selections
    """
    print("\n" + "=" * 70)
    print("üéπ FLEXIBLE MUSIC ENCODER - INTERACTIVE CONFIGURATION")
    print("=" * 70)

    config = MusicConfig()

    # Instrument selection
    print("\nüéª AVAILABLE INSTRUMENTS:")
    for i, instrument in enumerate(InstrumentType, 1):
        print(f"   {i:2}. {instrument.value.capitalize():12}", end="")
        if i % 4 == 0:
            print()
    print()

    while True:
        try:
            choice = int(input(f"Select instrument (1-{len(InstrumentType)}): "))
            if 1 <= choice <= len(InstrumentType):
                config.instrument = list(InstrumentType)[choice - 1]
                break
            else:
                print(f"Please enter a number between 1 and {len(InstrumentType)}")
        except ValueError:
            print("Please enter a valid number")

    # Scale selection
    print("\nüéº AVAILABLE SCALES:")
    for i, scale in enumerate(ScaleType, 1):
        print(f"   {i:2}. {scale.value.replace('_', ' ').title():15}", end="")
        if i % 3 == 0:
            print()
    print()

    while True:
        try:
            choice = int(input(f"Select scale (1-{len(ScaleType)}): "))
            if 1 <= choice <= len(ScaleType):
                config.scale = list(ScaleType)[choice - 1]
                break
            else:
                print(f"Please enter a number between 1 and {len(ScaleType)}")
        except ValueError:
            print("Please enter a valid number")

    # Note duration
    print("\n‚è±Ô∏è  NOTE DURATION:")
    print("   1. Very short (0.1 seconds)")
    print("   2. Short (0.2 seconds)")
    print("   3. Medium (0.3 seconds) - Default")
    print("   4. Long (0.5 seconds)")
    print("   5. Very long (1.0 seconds)")
    print("   6. Custom duration")

    while True:
        try:
            choice = input("Select duration option (1-6): ")
            if choice == "1":
                config.note_duration = 0.1
                break
            elif choice == "2":
                config.note_duration = 0.2
                break
            elif choice == "3":
                config.note_duration = 0.3
                break
            elif choice == "4":
                config.note_duration = 0.5
                break
            elif choice == "5":
                config.note_duration = 1.0
                break
            elif choice == "6":
                try:
                    custom = float(input("Enter custom duration in seconds: "))
                    if 0.01 <= custom <= 10.0:
                        config.note_duration = custom
                        break
                    else:
                        print("Please enter a value between 0.01 and 10.0")
                except ValueError:
                    print("Please enter a valid number")
            else:
                print("Please enter 1, 2, 3, 4, 5, or 6")
        except:
            print("Invalid input")

    # Number of entries
    print("\nüìä NUMBER OF ENTRIES TO PROCESS:")
    print("   1. All entries")
    print("   2. First 1,000 entries (for testing)")
    print("   3. First 10,000 entries")
    print("   4. First 50,000 entries")
    print("   5. Custom number")

    while True:
        try:
            choice = input("Select option (1-5): ")
            if choice == "1":
                config.max_entries = None
                break
            elif choice == "2":
                config.max_entries = 1000
                break
            elif choice == "3":
                config.max_entries = 10000
                break
            elif choice == "4":
                config.max_entries = 50000
                break
            elif choice == "5":
                try:
                    custom = int(input("Enter custom number: "))
                    if custom > 0:
                        config.max_entries = custom
                        break
                    else:
                        print("Please enter a positive number")
                except ValueError:
                    print("Please enter a valid number")
            else:
                print("Please enter 1, 2, 3, 4, or 5")
        except:
            print("Invalid input")

    # Advanced options
    print("\n‚öôÔ∏è  ADVANCED OPTIONS:")
    advanced = input("Configure advanced options? (y/n): ").lower()
    if advanced == 'y':
        # Volume
        try:
            volume = float(input(f"Volume (0.0 to 1.0, default {config.volume}): ") or config.volume)
            if 0.0 <= volume <= 1.0:
                config.volume = volume
        except:
            print("Using default volume")

        # Base octave
        try:
            octave = int(input(f"Base octave (0-8, default {config.base_octave}): ") or config.base_octave)
            if 0 <= octave <= 8:
                config.base_octave = octave
        except:
            print("Using default octave")

        # Rest duration
        try:
            rest = float(
                input(f"Rest between notes in seconds (default {config.rest_duration}): ") or config.rest_duration)
            if 0.0 <= rest <= 1.0:
                config.rest_duration = rest
        except:
            print("Using default rest duration")

        # Reverb
        try:
            reverb = float(input(f"Reverb level (0.0 to 1.0, default {config.reverb_level}): ") or config.reverb_level)
            if 0.0 <= reverb <= 1.0:
                config.reverb_level = reverb
        except:
            print("Using default reverb")

    return config


def main():
    """Main function to run the flexible music encoder."""

    print("=" * 70)
    print("üéµ FLEXIBLE MUSIC ENCODER")
    print("=" * 70)

    # File configuration
    CSV_FILE = "dictQM_LL_single_digit_06_Dec_2025.csv"

    # Get configuration
    print("\nChoose configuration method:")
    print("   1. Interactive configuration")
    print("   2. Load from config file")
    print("   3. Use default settings")

    config_choice = input("\nSelect option (1-3): ").strip()

    if config_choice == "1":
        config = interactive_configuration()
    elif config_choice == "2":
        config = MusicConfig()  # Start with defaults
        encoder = FlexibleMusicEncoder(config)
        encoder.load_config()
        config = encoder.config
    else:
        config = MusicConfig()  # Use defaults

    # Initialize encoder
    encoder = FlexibleMusicEncoder(config)

    # Read weights from CSV
    weights = encoder.read_csv_weights(CSV_FILE)

    if not weights:
        print("‚ùå No valid weights found. Exiting.")
        return

    # Generate output filename
    output_file = f"music_{config.instrument.value}_{config.scale.value}.wav"

    # Encode to music
    audio = encoder.encode_to_music(weights, output_file)

    # Save configuration
    save_config = input("\nüíæ Save configuration to file? (y/n): ").lower()
    if save_config == 'y':
        encoder.save_config()

    # Create simple waveform preview
    if len(audio) > 0:
        try:
            plt.figure(figsize=(12, 4))
            preview_samples = min(44100, len(audio))  # First second
            plt.plot(audio[:preview_samples])
            plt.title(
                f"Waveform Preview - {config.instrument.value.capitalize()}, {config.scale.value.replace('_', ' ').title()}")
            plt.xlabel("Samples")
            plt.ylabel("Amplitude")
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            plt.savefig("waveform_preview.png", dpi=150)
            plt.close()
            print(f"\nüìà Waveform preview saved as: waveform_preview.png")
        except Exception as e:
            print(f"\n‚ö†Ô∏è  Could not create preview plot: {e}")

    print("\n" + "=" * 70)
    print("‚úÖ ENCODING COMPLETE!")
    print(f"   Output file: {output_file}")
    print("=" * 70)


if __name__ == "__main__":
    main()